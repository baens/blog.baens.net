---
title: "Notes from experimenting with simpleflatmapper"
date: 2018-02-19
---

When I was a C# developer, I adored the different Micro-ORMs that were available. If I can recall correctly, [Massive](https://github.com/FransBouma/Massive) was one of the first ones I heard about. The idea that I could just write straight SQL and get objects out without any other configuration I loved. When I got back into Java, I always wondered if there were such a thing out there.

Well I've finally found a decent one. The library is called [Simpleflatmapper](http://simpleflatmapper.org/). With no XML configuration file, I can get from SQL to object with out any problem. This is amazing!

Let's see some code

In the examples I have a postgres database running with the following table setup

```sql
CREATE TABLE test(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, data text);
INSERT INTO test(data) VALUES('1'),('2'),('3'),('4');
```

So here is my first shot just trying to iterate over those

```kotlin
import org.simpleflatmapper.jdbc.JdbcMapperFactory
import java.util.stream.Stream

fun main(args: Array<String>) {
    Class.forName("org.postgresql.Driver") // load JDBC driver

    getData().forEach { println(it) }
}

// Data class representing a row. Did I mention how neat Kotlin is?
data class DataRow(val id: Int, val data: String)


/*
    This is the SimpleFlatMapper part. This creates a class 
    that knows how to map over the DataRow objects. This is needed because
    looking up certain fields and other reflection like tasks can be cached for
    performance reasons. So we have something that 
    can be smart about doing those for us
 */
val mapper = JdbcMapperFactory.newInstance().newMapper(DataRow::class.java)

fun getData() : Stream<DataRow> {
    val connection = DriverManager.getConnection("jdbc:postgresql://localhost:5432/postgres", "postgres", "password");
    val statement = connection.prepareStatement("SELECT id, data FROM test")
    val resultSet = statement.executeQuery()
    return mapper.stream(resultSet)
}
```

If you ran this with everthing setup (repository here) you could see the following:

```
DataRow(id=1, data=1)
DataRow(id=2, data=2)
DataRow(id=3, data=3)
DataRow(id=4, data=4)
```

Neat!

But of course that isn't everything. We need to clean up after ourselves. Database connections in Java have a lot of cruft that can be left over. What I'm talking about specifically in this case is the database connection.

First let's experiment to see how bad the problem really is. So let's get a base line by running this SQL on the database to see what a "quiet" database looks like.

```sql
SELECT query, count(*) FROM pg_stat_activity group by query;
```

You should get something that looks like this:

query | count
------|------
SELECT query, count(*) FROM pg_stat_activity group by query | 1

Now let's modify the main loop to do the query 10 times and wait for user input so we can inspect the database.

```kotlin
fun main(args: Array<String>) {
    Class.forName("org.postgresql.Driver")

    for(i in 1..10) {
        getData().forEach { println(it) }
    }

    println("holding")
    readLine()
}
```

You should now see something like this

query | count
------|------
SELECT query, count(*) FROM pg_stat_activity group by query | 1
SELECT id, data FROM test | 10

ACK! We have 10 open query sessions. That's not going to scale very well. And just to prove how fast it won't scale, instead of 10, do 100. There should be an exception stating that there are too many open connections.

Let's fix this. So Java streams have the ability to do something once they are closed. So let's change our `getData` method to this:

```kotlin
fun getData() : Stream<DataRow> {
    val connection = DriverManager.getConnection("jdbc:postgresql://localhost:5432/postgres", "postgres", "password");

    val statement = connection.prepareStatement("SELECT id, data FROM test")

    val resultSet = statement.executeQuery()

    return mapper.stream(resultSet)
                 .onClose {
                    println("closing connection")
                    resultSet.close()
                    statement.close()
                    connection.close()
                 }
}
```

And if we run that....well we still have the same issue. This is because a `Stream` is "resourceful". I.e. it can hold on to resources as it works waiting for the right time to clean up. And sadly it can't do that automatically for us, so we need to tell it when to shut things down. Now, in normal Java you have something called [`try with resource`](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html). But in Kotlin, it's actually fairly straight forward with the `use` statement. For example this is how our main loop will now look:

```kotlin
fun main(args: Array<String>) {
    Class.forName("org.postgresql.Driver")

    for(i in 1..20) {
        getData().use {
            it.forEach { println(it) }
        }
    }

    println("holding")
    readLine()
}
```

That `use` block is what is the important piece. It says to use the resource for this block, and once done, dispose of it. Sadly we have to be explicit in the usage otherwise resources won't get cleaned up.

Now if you run this piece, you should get to the `holding` line. And you should see this table as the result

query | count
------|------
SELECT query, count(*) FROM pg_stat_activity group by query | 1

MUCH better, we now only have our one connection running this query. Excellent, we are being clean with our approach and with any luck aren't leaking memory anywhere. 

So there you have it. I like this setup a lot and can start using this in my projects. I'm always a fan of these simpler ways, and especially if I can lose out on the huge libraries that ORMs can become. 
