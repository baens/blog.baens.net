<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Erik Lindblom&#39;s Ramblings</title>
    <link>https://blog.baens.net/</link>
    <description>Recent content on Erik Lindblom&#39;s Ramblings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Jun 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.baens.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Setting up a development workspace for Postgres and vault</title>
      <link>https://blog.baens.net/posts/postgres-vault-dev-workspace/</link>
      <pubDate>Wed, 13 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/postgres-vault-dev-workspace/</guid>
      <description>My current line of work has led me to start getting into docker more and more. One of the neat things I&amp;rsquo;ve been getting to play with is using Postgres as my database and Vault for secrets management. I figured it was time to showcase what a basic development workspace looks like to help get someone up and running quickly.
I&amp;rsquo;ve hopefully boiled this down into the smallest pieces needed to make things work.</description>
    </item>
    
    <item>
      <title>Adding tests to Kotlin &amp; JAX-RS (Jersey) project</title>
      <link>https://blog.baens.net/posts/add-tests-to-jaxrs-setup/</link>
      <pubDate>Mon, 28 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/add-tests-to-jaxrs-setup/</guid>
      <description>I have a blog post about setting up a JAX-RS with Kotlin and one thing I neglected to show was how to test. So, let&amp;rsquo;s go back and fix this. For this, I will be using JUnit 5 for the test runner, AssertJ as the assertion library, and Mockito as the mocking framework.
Let&amp;rsquo;s go over quickly what tests I&amp;rsquo;ve found valuable as I&amp;rsquo;ve created JAX-RS services. Well, in reality, there&amp;rsquo;s only two: one that exercises the HTTP interface (so, &amp;ldquo;integration test&amp;rdquo;) and one that tests the class and methods in isolation (so, &amp;ldquo;unit tests&amp;rdquo;).</description>
    </item>
    
    <item>
      <title>Notes from experimenting with GraphQL and Kotlin</title>
      <link>https://blog.baens.net/posts/experiment-notes-graphql-postgres/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/experiment-notes-graphql-postgres/</guid>
      <description>What is this GraphQL thing I have finally got time to try out GraphQL. I&amp;rsquo;ve been reading about it more and more and wanted to get a sense of how to build a data API with it. Now, if you don&amp;rsquo;t know what GraphQL is, here is my take on it. It is a way to create data APIs that allow clients to tell you what data they actually need.</description>
    </item>
    
    <item>
      <title>Notes from experimenting with JAX-RS and Streams</title>
      <link>https://blog.baens.net/posts/experiment-notes-jaxrs-stream/</link>
      <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/experiment-notes-jaxrs-stream/</guid>
      <description>So, this idea is a slight continuation on from my notes of how to get a stream out of JDBC using the Simpleflatmapper library.
The goal here is to make it so I can send a stream of objects out with JAX-RS (Jersey). This makes it possible to have lazy evaluation of a stream of data from a database that gets pushed up to the browser as soon as it comes off the database.</description>
    </item>
    
    <item>
      <title>Notes from experimenting with simpleflatmapper</title>
      <link>https://blog.baens.net/posts/experiment-notes-simpleflatmapper/</link>
      <pubDate>Fri, 23 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/experiment-notes-simpleflatmapper/</guid>
      <description>When I was a C# developer, I adored the different Micro-ORMs that were available. Massive was one of the first ones I heard about and used. The idea that I could just write straight SQL and get objects out without any other configuration I loved. When I got back into the JVM world, I always wondered if there were such a thing out there.
Well I&amp;rsquo;ve finally found a decent one.</description>
    </item>
    
    <item>
      <title>Step-by-step: Kotlin, JAX-RS (Jersey), and Docker</title>
      <link>https://blog.baens.net/posts/step-by-step-kotlin-jaxrs-hello-world/</link>
      <pubDate>Sat, 17 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/step-by-step-kotlin-jaxrs-hello-world/</guid>
      <description>Hello Again and welcome to another blog post in my ongoing series on step-by-step tutorials. This one will actually build atop the last Hello Kotlin one and make a JAX-RS web service. This particular implementation of JAX-RS will be Jersey. Jersey is actually the reference implementation from Oracle, but there are a few out there that I&amp;rsquo;ve honestly haven&amp;rsquo;t given enough time.
Step 0: Prerequisites For this one, I am going to start off with my Kotlin Hello World repository.</description>
    </item>
    
    <item>
      <title>Step-by-step: Kotlin and Docker</title>
      <link>https://blog.baens.net/posts/step-by-step-kotlin/</link>
      <pubDate>Mon, 12 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/step-by-step-kotlin/</guid>
      <description>This is part of a series of blog posts that I&amp;rsquo;ve always wanted todo. Read about them here.
For this step-by-step guide let&amp;rsquo;s do something basic and get kotlin compiling and running inside a docker container.
The companion repository is here.
Step 0: Prerequisites I am going to assume you have the following installed and already running. We will be using the local gradle wrapper instance after the initial setup, but you do need it for the initial creation.</description>
    </item>
    
    <item>
      <title>Blog Series: The step-by-step way tutorial</title>
      <link>https://blog.baens.net/posts/step-by-step-series/</link>
      <pubDate>Sun, 11 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/step-by-step-series/</guid>
      <description>Over the course of my development career, I&amp;rsquo;ve always tend to enjoy tutorials or explanations that guide you through concepts or frameworks step by step. Ones that have a goal and slowly work through things step by step, building upon itself to reach the final destination. All while explaining why this piece fits there or pros and cons of this piece over here.
These trainings are usually harder to come by because everyone is looking for a quick fix, or tool that does it for you automagically.</description>
    </item>
    
    <item>
      <title>Talking to a HTTP server via Telnet</title>
      <link>https://blog.baens.net/posts/http-with-telnet/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.baens.net/posts/http-with-telnet/</guid>
      <description>Have you ever tried to talk to a HTTP server via Telnet? As web developers, either front end or backend, we should strive to at least strive to have a understanding of the technologies we build our success on. And I&amp;rsquo;ve found through out the years that a surprising number of web developers don&amp;rsquo;t know how it works. So I thought it was fitting to start by looking at the basics of the communication mechanism we build upon and use every day, HTTP.</description>
    </item>
    
  </channel>
</rss>